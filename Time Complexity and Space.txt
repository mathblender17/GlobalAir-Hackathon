Time Complexity and Space

MODULE 1
â±ï¸ Time Complexity
1. loadAirports()
Reads and parses n lines, each with fixed fields.

Tokenization and parsing each line: O(1) per line (as number of fields per airport is fixed).

âœ… Time: O(n) â€” where n is the number of lines (airports) in airports.dat.

2. loadRoutes()
Reads and parses m lines, each representing a flight/route.

For each route, looks up two airports (source and destination) in a hash map: O(1) average-case per lookup.

Haversine formula is constant time: O(1).

âœ… Time: O(m) â€” where m is the number of lines (routes) in routes.dat.

3. displayGraph()
Iterates over all nodes and their adjacency lists.

Let:

V = number of airports with valid outgoing flights

E = total number of flight routes

âœ… Time: O(V + E)

ğŸ’¾ Space Complexity
1. Airports Storage
Stored in an unordered_map<string, Airport>: one entry per valid airport.

âœ… Space: O(n)

2. Adjacency List
Stored as unordered_map<string, vector<FlightEdge>>

Stores all directed edges (i.e., flight routes)

âœ… Space: O(E)

3. Total Space
âœ… O(n + E)

ğŸ“Œ Summary
Operation	Time Complexity	Space Complexity
loadAirports()	O(n)	O(n)
loadRoutes()	O(m)	O(E)
displayGraph()	O(V + E)	â€”
Total	O(n + m)	O(n + E)

Where:

n = number of airport records

m = number of route records (E = #edges)

V = number of airports with at least one outgoing flight


========================================================================
MODULE 2

âœ… Time and Space Complexity â€” Module 2 (Shortest Path Finder)
ğŸ§® 1. Dijkstra's Algorithm
âœ” When implemented using a Min-Heap (priority queue):
cpp
Copy code
priority_queue<pair<double, string>, vector<pair<double, string>>, greater<>> pq;
- Time Complexity:
Initialization: O(V)

Main loop:

Each vertex is pushed into the priority queue at most once â†’ O(V)

For each edge, we may update the distance and push into the heap â†’ O(E log V)

â¡ Total: O((V + E) log V)

Where:

V = number of vertices (airports â‰ˆ 6000)

E = number of edges (routes â‰ˆ 60,000â€“80,000)

- Space Complexity:
dist, parent, visited maps â†’ O(V)

Priority queue â†’ O(V)

Adjacency list â†’ O(V + E)

â¡ Total: O(V + E)

ğŸ§® 2. Bellman-Ford Algorithm
âœ” Bellman-Ford works for graphs with negative edge weights, unlike Dijkstra.
- Time Complexity:
V - 1 iterations over all edges:

Inner loop: O(E)

Final check for negative cycles: O(E)

â¡ Total: O(V Ã— E)

For large graphs, Bellman-Ford is slower, especially with 6,000 nodes and ~60,000+ edges:

plaintext
Copy code
Estimated ~360 million operations = O(6000 Ã— 60000)
Hence, it takes noticeable time, as you saw in real runs.

- Space Complexity:
dist and parent maps â†’ O(V)

No heap/priority queue

Adjacency list already exists â†’ O(V + E)

â¡ Total: O(V + E)

ğŸ“Œ Summary Table
Algorithm	Time Complexity	Space Complexity	Use Case
Dijkstra	O((V + E) log V)	O(V + E)	Fastest for non-negative weights
Bellman-Ford	O(V Ã— E)	O(V + E)	For negative weights (e.g., penalties)
=======================================
Module 3 - bagage routing

âœ… BaggageBST (Binary Search Tree)
1. insert(Baggage b)
Best / Avg Case (Balanced BST):
â± Time: O(log n)
ğŸ’¾ Space: O(log n) (due to recursive calls)

Worst Case (Unbalanced BST):
â± Time: O(n)
ğŸ’¾ Space: O(n)

â¡ï¸ Unbalanced BST happens if you insert sorted baggage IDs.

2. printInOrder() and printCategory()
Time: O(n) (visits every node)

Space: O(h) recursion stack, where h is height of tree

3. searchByCategory()
Not indexed, so it's essentially an in-order traversal:
â± Time: O(n)
ğŸ’¾ Space: O(h) (recursive)

âœ… BaggageMinHeap (Priority Queue with Custom Comparator)
1. push(Baggage b)
Internally uses binary heap
â± Time: O(log n)
ğŸ’¾ Space: O(1) (heap grows, but each push is constant size)

2. pop()
Removes and reorders the heap
â± Time: O(log n)
ğŸ’¾ Space: O(1)

3. empty()
Just checks if vector is empty
â± Time: O(1)
ğŸ’¾ Space: O(1)

âœ… computeUrgency()
Simple arithmetic operation
â± Time: O(1)
ğŸ’¾ Space: O(1)

âœ… loadBaggageFromCSV()
Assuming n lines (excluding header):

â± Time: O(n) (parsing each line once)

ğŸ’¾ Space: O(n) (stores all n Baggage structs in memory)

âœ… main()
Assuming n baggage records:

Step	Time Complexity	Space Complexity
Loading from CSV	O(n)	O(n)
BST insertion	O(n log n) avg, O(nÂ²) worst	O(n)
Min Heap insertion	O(n log n)	O(n)
BST traversal	O(n)	O(h)
Heap popping	O(n log n)	O(1) each

ğŸ“Š Summary Table
Component	Operation	Time Complexity	Space Complexity
BST	Insert	O(log n) avg, O(n) worst	O(log n) recursion
Inorder/Category	O(n)	O(h) recursion
Min Heap	Insert	O(log n)	O(1)
Pop	O(log n)	O(1)
CSV Loader	Load	O(n)	O(n)
Urgency Calc	computeUrgency	O(1)	O(1)

========================================
MOdule 3 + extesnidon special use case 1


ğŸ§® Module 3: Baggage Flow System
Functionality	Time Complexity	Space Complexity	Notes
âœ… BST::insert()	O(log n) avg, O(n) worst	O(log n) recursion stack	Unbalanced BST = worst case O(n)
âœ… BST::printInOrder()	O(n)	O(h) recursion stack	h = height of BST
âœ… BST::printCategory()	O(n)	O(h)	No indexing by category
âœ… MinHeap::push()	O(log n)	O(1)	Heap maintains sorted order
âœ… MinHeap::pop()	O(log n)	O(1)	Each pop returns most urgent
âœ… computeUrgency()	O(1)	O(1)	Simple arithmetic

ğŸ‹ï¸ Specialized Use Case: Baggage Weight Balancer (Exact DP)
ğŸ“Œ Problem: Split baggage into two groups with near-equal total weight
âœ… Function: balanceBaggageWeight(vector<Baggage>& bags)
Let:

n = number of baggage items

S = total sum of weights

T = S / 2 = target weight to reach

Component	Time Complexity	Space Complexity	Notes
Total weight calc	O(n)	O(1)	Single loop
DP table build	O(n Ã— T)	O(n Ã— T)	T â‰ˆ sum(weights)/2
Backtracking assignments	O(n)	O(n)	Based on tracking list
Group summation (accumulate)	O(n)	O(1)	Final total weights

ğŸ” Example from your run:
Total weight = 122

Target = 61

DP matrix size = 6 x 61

â†’ Practically efficient âœ…

ğŸ§  Summary Table
Component	Time Complexity	Space Complexity
Module 3 (BST + MinHeap)	O(n log n) total	O(n)
Weight Balancer (DP)	O(n Ã— T) where T â‰ˆ sum/2	O(n Ã— T)

ğŸ’¡ Optimization Notes:
You can reduce space in DP from O(nÃ—T) to O(T) using 1D DP with rolling update.

If T is too large, use a Greedy Approximate algorithm (O(n log n)).
===========================
Module 4 - track lost baggage ;-
âœ… Complexity Per Operation
1. insert(Baggage b)
Time: O(1)

Space: O(1)

Why: Append to tail of linked list + insert into hash map.

2. remove(int baggageID)
Time: O(1)

Space: O(1)

Why: Use hash map to find node in O(1) and unlink in constant time.

3. getBaggageInfo(int baggageID)
Time: O(1)

Space: O(1)

Why: Direct lookup in unordered_map.

4. printFlow()
Time: O(n)

Space: O(1)

Why: Linear traversal from head to tail of doubly linked list.

âœ… Total Storage Usage
Let n = number of bags in transit:

Component	Space Used	Reason
Hash Table	O(n)	One entry per baggage ID
Doubly Linked List	O(n)	One node per bag
Total	O(n)	Combined hash map + list

ğŸ“Š Summary Table
Operation	Time Complexity	Space Complexity
insert()	O(1)	O(1)
remove()	O(1)	O(1)
getBaggageInfo()	O(1)	O(1)
printFlow()	O(n)	O(1)
Total System Storage	â€”	O(n)
=========
MODULE 5-----
âœ… Module 5 Overview
ğŸ“¦ Inputs:
n = number of records (rows in delay_data.csv)

m = number of airports (typically 50â€“500 in real datasets)

E = number of directed edges (flights with origin â†’ destination)

ğŸ§© Part 1: Seasonal Delay Trends (Tabulation)
ğŸ”§ Operations:
Loading CSV:

Time: O(n)

Space: O(n) (stores all rows)

Building monthlyDelays (airport â†’ month â†’ delays[]):

Time: O(n) (each row appended)

Space: O(m Ã— 12 Ã— k) where k is average delays per month-airport

Computing Monthly Averages:

Time: O(m Ã— 12 Ã— k) â‰ˆ O(n)

Space: O(m Ã— 12) for avgDelays

Top Airport Sorting for a Month:

Time: O(m log m) (since sorting airport averages)

Space: O(m) for result vector

âœ… Part 1 Summary
Metric	Value
â± Time	O(n + m log m)
ğŸ§  Space	O(n + m Ã— 12)

ğŸ§© Part 2: Longest Delay Chain (Graph + DP)
ğŸ”§ Operations:
Build Graph:

Time: O(n) (1 edge per record)

Space: O(E)

Memoized DFS on Graph:

For each node, visits each edge once.

Time: O(m + E) (classic DP on DAG)

Space:

memo: O(m)

visiting set: O(h) where h is DFS recursion height (â‰¤ m)

findLongestDelayChain():

Calls DFS for every node once

Total: O(m + E) (no recomputation due to memoization)

âœ… Part 2 Summary
Metric	Value
â± Time	O(m + E)
ğŸ§  Space	O(m + E)

ğŸš€ Final Complexity (Full Module 5)
Component	Time Complexity	Space Complexity
Load CSV	O(n)	O(n)
Monthly Avg	O(n)	O(m Ã— 12)
Sort Top Airports	O(m log m)	O(m)
Build Graph	O(n)	O(E)
Memoized DFS	O(m + E)	O(m + E)

âœ… Total Time: O(n + m log m + E)
âœ… Total Space: O(n + m Ã— 12 + E)
===========================
Module 6 :-
ğŸ”§ Module 6 Breakdown
Let:
n = number of flights (input size)

ğŸ§  Step-by-Step Complexity
1. CSV File Loading (loadFlightsFromCSV)
Time: O(n)

Each line read and parsed into a Flight object

Space: O(n)

Stored in a vector<Flight>

2. Merge Sort with Custom Comparator
Time: O(n log n)

Merge sort always divides input into halves â†’ log n levels

Merging at each level takes O(n) time

Custom comparator runs in O(1) per comparison (constant work)

Space: O(n)

Temporary vectors for left and right halves during merge

3. Comparator (compareFlights)
Time per comparison: O(1)

Time conversion: HH:MM â†’ minutes: O(1)

Priority lookups using if-else or map: O(1)

Total comparisons: O(n log n)

âœ… Final Summary
Operation	Time Complexity	Space Complexity
CSV File Loading	O(n)	O(n)
Merge Sort (custom)	O(n log n)	O(n)
Comparator Function	O(1) per call	â€”
Overall (Module 6)	O(n log n)	O(n)

--===========

MODULE 7 :
ğŸ§  Letâ€™s define:
r = number of route entries (e.g., origin â†’ dest pairs)

d = total number of delays per route (usually small, â‰ˆ 3â€“10)

c = number of flight connection pairs

j = number of baggage checkpoints

âœ… 1. Top 5 Delay-Prone Routes
ğŸ”§ Data Structures:
Input: vector<pair<string, string>> of routes

Delay map: unordered_map<string, vector<double>>

ğŸ“Š Complexity:
Operation	Time	Space
Look up and average delays	O(r Ã— d)	O(r)
Sorting top 5 by avg delay	O(r log r)	O(r)
Total	O(r log r)	O(r)

âœ… 2. Top 5 Baggage Jam Points
ğŸ”§ Data Structures:
Input: unordered_map<string, int>

ğŸ“Š Complexity:
Operation	Time	Space
Copy into vector	O(j)	O(j)
Sort jam counts	O(j log j)	O(j)
Total	O(j log j)	O(j)

âœ… 3. Flights at Risk
ğŸ”§ Data Structures:
Input: vector<FlightConnection>

ğŸ“Š Complexity:
Operation	Time	Space
Convert times & compare	O(c)	O(c)
Store filtered connections	O(c)	O(c)
Total	O(c)	O(c)

âœ… Final Summary
Module Component	Time Complexity	Space Complexity
Top Delay Routes	O(r log r)	O(r)
Baggage Jam Detection	O(j log j)	O(j)
Flight Risk Detection	O(c)	O(c)
Overall Module 7	O(r log r + j log j + c)	O(r + j + c)

âœ… Why Itâ€™s Efficient
Uses hash maps for O(1) lookup

Sorting only a few elements (r, j are small)

No recomputation thanks to one-pass aggregation

-=================
Special use case - 2

ğŸš€ Algorithm Summary
You're doing a DFS traversal over a directed flight graph (adjList), from a source to a destination, with constraints:

Max hops â‰¤ 2

Layover â‰¤ 180 mins

Cost â‰¤ $1200

Each path is:

Tracked (path vector)

Pruned (if cost or hops exceed limit)

â± Time Complexity
Letâ€™s define:

n: number of airports (vertices)

e: number of routes (edges)

k: max depth of DFS (â‰¤ 2 hops â†’ depth â‰¤ 3)

b: average branching factor (edges per airport)

ğŸ” Worst-case time complexity:
Since we prune DFS aggressively, the actual complexity is much less than a full traversal.

But worst-case (without pruning):

scss
Copy
Edit
O(b^k)
For your case:

k = 2 (max 2 hops â†’ 3 nodes in path)

So, worst-case DFS path expansion:

scss
Copy
Edit
O(b^3)
And since we check each neighbor of curr, each level has at most b calls.

âœ… In practice:
Because of cost + layover pruning, most branches terminate early

So actual performance is close to linear or small exponential in constrained path space

ğŸ§  Space Complexity
You're storing:

path vector (max size 3 per recursion): O(k)

results vector of valid paths: O(p * k) where p is number of valid routes

memo (not used in constrained DFS): negligible here

So overall:
ini
Copy
Edit
Space = O(p * k)
In worst-case: p could be hundreds (you saw 100+ results)

k = 3 (3-airport path max)

âœ… Final Summary
Resource	Complexity	Explanation
Time (worst)	O(b^k)	DFS with max depth 3 (due to 2-hop limit)
Time (practical)	O(valid paths)	Heavily pruned using cost/layover limits
Space	O(p * k)	p = valid routes, k â‰¤ 3 per path